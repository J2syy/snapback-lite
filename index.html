<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
<title>SNAPBACK Photo Booth</title>

<style>
/* ===== AESTHETIC DESIGN TOKENS ===== */
:root {
  --bg-gradient: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
  --accent: #ff8fa3; 
  --dark: #2b2b2b;
  --surface: rgba(255, 255, 255, 0.7);
  --surface-blur: blur(12px);
  --radius: 20px;
  --shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
  --theme-color: #ffffff; 
}

* {
  box-sizing: border-box;
  font-family: "SF Pro Rounded", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  -webkit-tap-highlight-color: transparent;
}

body {
  margin: 0;
  background: var(--bg-gradient);
  color: var(--dark);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 15px 10px;
  overflow-x: hidden;
}

/* ===== HEADER ===== */
header {
  text-align: center;
  margin-bottom: 12px;
  width: 100%;
  max-width: 420px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 10px;
}

.brand {
  text-align: left;
}

h1 {
  margin: 0;
  letter-spacing: 1px;
  font-size: 22px;
  font-weight: 800;
  background: -webkit-linear-gradient(45deg, var(--accent), #ffaa77);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.tagline {
  font-size: 11px;
  font-weight: 600;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.admin-btn {
  background: transparent;
  border: none;
  font-size: 20px;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.2s;
  padding: 5px;
}
.admin-btn:active {
  opacity: 1;
}

/* ===== VIEWPORT & LIVE TEMPLATE ===== */
.view-container {
  position: relative;
  width: 100%;
  max-width: 420px;
  height: 62vh; /* Scalable height to fit long strips naturally */
  min-height: 400px;
  max-height: 650px;
  border-radius: var(--radius);
  overflow: hidden;
  background: #000;
  box-shadow: var(--shadow);
  margin-bottom: 15px;
}

/* The physical canvas that the user sees in real time */
#livePrintOut {
  width: 100%;
  height: 100%;
  background: var(--theme-color);
  display: flex;
  flex-direction: column;
  padding: 4%;
  box-sizing: border-box;
  transition: background 0.3s ease;
}

#liveGrid {
  flex: 1;
  display: grid;
  gap: 4%;
  min-height: 0; 
}

.grid-slot {
  background: rgba(0,0,0,0.1); /* Dark placeholder for empty slots */
  position: relative;
  border: 1px solid rgba(0,0,0,0.05);
  overflow: hidden;
  border-radius: 4px;
}

/* All video and captured images perfectly fill their slots */
.grid-slot video, .grid-slot img {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  object-fit: cover;
  z-index: 1;
}

/* The filter tint wrapper specifically for the live video */
#videoOverlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  transition: background 0.3s ease;
  z-index: 2;
}

#liveText {
  text-align: center;
  padding-top: 4%;
  flex-shrink: 0;
}

.event-title {
  font-weight: 900;
  font-size: 18px;
  letter-spacing: 1px;
  margin: 0;
  text-transform: uppercase;
  transition: color 0.3s ease;
}

.event-subtitle {
  font-size: 10px;
  margin-top: 2px;
  font-weight: 600;
  letter-spacing: 2px;
  transition: color 0.3s ease;
}

#flashOverlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  background: white;
  opacity: 0;
  pointer-events: none;
  z-index: 10;
}

/* ===== SEQUENCE UI ===== */
#sequenceIndicator {
  position: absolute;
  top: 15px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.6);
  color: white;
  padding: 6px 14px;
  border-radius: 14px;
  font-size: 13px;
  font-weight: bold;
  z-index: 20;
  backdrop-filter: blur(4px);
  letter-spacing: 1px;
}

#countdownOverlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 100px;
  font-weight: 900;
  color: white;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  z-index: 20;
  transition: transform 0.1s ease;
}

/* ===== GUEST CONTROLS PANEL ===== */
.control-panel {
  width: 100%;
  max-width: 420px;
  background: var(--surface);
  backdrop-filter: var(--surface-blur);
  border-radius: var(--radius);
  padding: 15px 10px;
  box-shadow: var(--shadow);
  border: 1px solid rgba(255,255,255,0.5);
  display: flex;
  flex-direction: column;
  gap: 12px;
  transition: opacity 0.3s ease;
}

.scroll-row {
  display: flex;
  flex-wrap: nowrap;
  overflow-x: auto;
  gap: 8px;
  padding-bottom: 5px;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.scroll-row::-webkit-scrollbar { display: none; }

.row-label {
  font-size: 11px;
  font-weight: 700;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-left: 5px;
  margin-bottom: -5px;
}

button.opt-btn {
  padding: 8px 16px;
  border-radius: 16px;
  border: 1px solid transparent;
  background: rgba(255,255,255,0.8);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
  color: #555;
  transition: all 0.2s ease;
}

button.opt-btn.active {
  background: var(--dark);
  color: white;
  border-color: var(--dark);
  transform: scale(1.05);
}

.action-row {
  display: flex;
  justify-content: space-around;
  align-items: center;
  margin-top: 5px;
}

.icon-btn {
  background: white;
  border: none;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  font-size: 20px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.06);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}
.icon-btn.active {
  background: #ffeb3b;
  box-shadow: 0 0 15px rgba(255, 235, 59, 0.5);
}

button.shutter {
  width: 76px;
  height: 76px;
  border-radius: 50%;
  background: var(--accent);
  border: 4px solid white;
  box-shadow: 0 0 0 2px var(--accent), 0 6px 15px rgba(255, 143, 163, 0.4);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: transform 0.1s ease;
}
button.shutter:active { transform: scale(0.92); }
button.shutter:disabled { opacity: 0.5; cursor: not-allowed; }

/* ===== ADMIN MODAL ===== */
.modal-overlay {
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(5px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}
.modal-overlay.active {
  opacity: 1;
  pointer-events: auto;
}

.modal-content {
  background: white;
  padding: 25px;
  border-radius: 24px;
  width: 90%;
  max-width: 340px;
  box-shadow: 0 20px 40px rgba(0,0,0,0.2);
  text-align: center;
}

.modal-content h3 { margin: 0 0 15px 0; font-size: 18px; }

.modal-content input[type="text"], 
.modal-content input[type="password"] {
  width: 100%;
  padding: 12px 15px;
  margin-bottom: 12px;
  border: 1px solid #ddd;
  border-radius: 12px;
  font-size: 14px;
  background: #f9f9f9;
}
.modal-content input:focus { outline: none; border-color: var(--accent); background: white; }

.btn-primary {
  width: 100%;
  padding: 12px;
  background: var(--dark);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 15px;
  font-weight: bold;
  cursor: pointer;
  margin-top: 10px;
}

/* Upload Actions Container */
#uploadControls {
  display: flex;
  gap: 10px;
  width: 100%;
  max-width: 420px;
  margin-top: 15px;
}
#uploadControls button {
  flex: 1;
  padding: 14px;
  border-radius: 16px;
  font-size: 15px;
  font-weight: bold;
  border: none;
  cursor: pointer;
}
#uploadBtn { background: var(--dark); color: white; }
#retakeBtn { background: white; color: var(--dark); box-shadow: 0 4px 10px rgba(0,0,0,0.05); }

/* Status Box */
#statusMessage {
  margin-top: 15px;
  padding: 12px 20px;
  border-radius: 16px;
  font-size: 14px;
  font-weight: 600;
  text-align: center;
  width: 100%;
  max-width: 420px;
}
#statusMessage.loading { background: #fff3cd; color: #856404; }
#statusMessage.success { background: #d4edda; color: #155724; }
#statusMessage.error { background: #f8d7da; color: #721c24; }
.hidden { display: none !important; }
</style>
</head>

<body>

<header>
  <div class="brand">
    <h1>SNAPBACK</h1>
    <div class="tagline">Event Photo Booth</div>
  </div>
  <!-- Hidden Admin Trigger -->
  <button class="admin-btn" id="openAdminBtn" title="Admin Settings">‚öôÔ∏è</button>
</header>

<div class="view-container" id="viewContainer">
  
  <!-- The physical live container showing the evolving grid -->
  <div id="livePrintOut">
    <div id="liveGrid"></div>
    <div id="liveText">
      <div class="event-title" id="overlayTitle"></div>
      <div class="event-subtitle" id="overlaySubtitle"></div>
    </div>
  </div>

  <div id="sequenceIndicator" class="hidden">Photo 1 of 4</div>
  <div id="countdownOverlay" class="hidden">3</div>
  <div id="flashOverlay"></div>
  
  <!-- Hidden elements used for rendering/streaming -->
  <canvas id="canvas" class="hidden"></canvas>
  <!-- These will be attached to slots dynamically via JS -->
  <video id="video" autoplay playsinline class="hidden"></video>
  <div id="videoOverlay" class="hidden"></div>
</div>

<div class="control-panel" id="mainControls">
  <!-- Layout Row (Guests choose grid type) -->
  <div class="row-label">üìê Layout</div>
  <div class="scroll-row" id="layoutControls"></div>

  <!-- Theme Row (Guests choose border colors) -->
  <div class="row-label">üñºÔ∏è Theme</div>
  <div class="scroll-row" id="themeControls"></div>

  <!-- Filters Row (Guests choose live color grading) -->
  <div class="row-label">üé® Filters</div>
  <div class="scroll-row" id="filterControls"></div>

  <!-- Action Row -->
  <div class="action-row">
    <button class="icon-btn" id="flashBtn" title="Toggle Flash">‚ö°</button>
    <button class="shutter" id="shutter"></button>
    <button class="icon-btn" id="flipBtn" title="Flip Camera">üîÑ</button>
  </div>
</div>

<div id="uploadControls" class="hidden">
  <button id="retakeBtn">Retake</button>
  <button id="uploadBtn">Upload to Gallery üöÄ</button>
</div>

<div id="statusMessage" class="hidden"></div>

<!-- Admin Modal (For text only) -->
<div class="modal-overlay" id="adminModal">
  <div class="modal-content">
    <h3>‚öôÔ∏è Admin Config</h3>
    
    <!-- Login Step -->
    <div id="adminLoginView">
      <input type="password" id="adminPin" placeholder="Enter PIN" inputmode="numeric">
      <button class="btn-primary" id="loginBtn">Unlock Settings</button>
    </div>

    <!-- Settings Step -->
    <div id="adminSettingsView" class="hidden">
      <input type="text" id="inputTitle" placeholder="Event Name" maxlength="25">
      <input type="text" id="inputSubtitle" placeholder="Event Subtitle" maxlength="35">
      <button class="btn-primary" id="saveAdminBtn">Save Config</button>
    </div>
  </div>
</div>

<script>
/* ================= GLOBAL STATE ================= */
let EVENT_NAME = "My Photobooth";
let EVENT_DATE = "Capture the moment";
const UPLOAD_URL = "https://script.google.com/macros/s/AKfycbxX9wMOWPLZrimEpvdojQsOh6ESW8kgBw3BK_qYX6VJC8s05tKgYS7BqrnULgrFS5zB/exec";

let stream = null;
let facingMode = "environment";
let flashEnabled = false;
const ADMIN_PIN = "1234"; 
let capturedPhotos = []; // Holds canvas frames during sequence

/* ================= CONFIGURATIONS ================= */
const LAYOUTS = {
  single: { name: "1 Photo", count: 1, cols: 1, rows: 1 },
  grid2:  { name: "2 Grid",  count: 2, cols: 2, rows: 1 },
  strip2: { name: "2 Strip", count: 2, cols: 1, rows: 2 },
  strip3: { name: "3 Strip", count: 3, cols: 1, rows: 3 },
  strip4: { name: "4 Strip", count: 4, cols: 1, rows: 4 },
  grid4:  { name: "4 Grid",  count: 4, cols: 2, rows: 2 },
  strip8: { name: "8 Strip", count: 8, cols: 1, rows: 8 },
  grid8:  { name: "8 Grid",  count: 8, cols: 2, rows: 4 }
};

const FRAMES = {
  polaroid: { name: "Classic White", bgFill: "#ffffff", textCol: "black" },
  midnight: { name: "Midnight Black", bgFill: "#1a1a1a", textCol: "white" },
  pastel:   { name: "Pastel Pink", bgFill: "#ffe4e1", textCol: "black" },
  blue:     { name: "Baby Blue", bgFill: "#e0f7fa", textCol: "black" },
  kraft:    { name: "Vintage Kraft", bgFill: "#dcb282", textCol: "black" }
};

const FILTERS = {
  none:    { name: "Original", css: "none", overlay: "transparent", vignette: false },
  warm:    { name: "Warm", css: "sepia(0.3) saturate(1.4) contrast(1.1)", overlay: "rgba(255, 140, 0, 0.05)", vignette: true },
  cool:    { name: "Cool", css: "saturate(0.8)", overlay: "rgba(0, 100, 255, 0.1)", vignette: false },
  vintage: { name: "Film", css: "sepia(0.6) contrast(1.2) brightness(0.9) saturate(1.2)", overlay: "transparent", vignette: true },
  bw:      { name: "B&W", css: "grayscale(1) contrast(1.2)", overlay: "transparent", vignette: true },
  soft:    { name: "Soft", css: "blur(1px) brightness(1.1) contrast(0.9)", overlay: "rgba(255, 255, 255, 0.1)", vignette: false },
  fade:    { name: "Fade", css: "contrast(0.8) brightness(1.2) saturate(0.7)", overlay: "rgba(255, 255, 255, 0.15)", vignette: false },
  cyan:    { name: "Cyan", css: "sepia(1) hue-rotate(180deg) saturate(1.5) contrast(1.1)", overlay: "rgba(0, 150, 255, 0.1)", vignette: true },
  vivid:   { name: "Vivid", css: "saturate(1.8) contrast(1.1)", overlay: "transparent", vignette: false },
  sepia:   { name: "Sepia", css: "sepia(0.8) contrast(1.1)", overlay: "transparent", vignette: true }
};

// Using strip4 instead of strip to match the updated LAYOUTS dictionary
let currentLayoutKey = "strip4";
let currentFrameKey = "polaroid";
let currentFilterKey = "none";

/* ================= DOM ELEMENTS ================= */
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const videoOverlay = document.getElementById("videoOverlay");
const flashOverlay = document.getElementById("flashOverlay");
const countdownOverlay = document.getElementById("countdownOverlay");
const sequenceIndicator = document.getElementById("sequenceIndicator");

const liveGrid = document.getElementById("liveGrid");
const overlayTitle = document.getElementById("overlayTitle");
const overlaySubtitle = document.getElementById("overlaySubtitle");

const layoutControls = document.getElementById("layoutControls");
const themeControls = document.getElementById("themeControls");
const filterControls = document.getElementById("filterControls");
const mainControls = document.getElementById("mainControls");
const uploadControls = document.getElementById("uploadControls");

const shutterBtn = document.getElementById("shutter");
const flipBtn = document.getElementById("flipBtn");
const flashBtn = document.getElementById("flashBtn");
const retakeBtn = document.getElementById("retakeBtn");
const uploadBtn = document.getElementById("uploadBtn");

const openAdminBtn = document.getElementById("openAdminBtn");
const adminModal = document.getElementById("adminModal");
const adminPin = document.getElementById("adminPin");
const loginBtn = document.getElementById("loginBtn");
const adminLoginView = document.getElementById("adminLoginView");
const adminSettingsView = document.getElementById("adminSettingsView");
const saveAdminBtn = document.getElementById("saveAdminBtn");

const inputTitle = document.getElementById("inputTitle");
const inputSubtitle = document.getElementById("inputSubtitle");

/* ================= INITIALIZATION ================= */
function initUI() {
  // 1. Generate Layout Buttons
  Object.keys(LAYOUTS).forEach(key => {
    const btn = document.createElement("button");
    btn.className = "opt-btn" + (key === currentLayoutKey ? " active" : "");
    btn.textContent = LAYOUTS[key].name;
    btn.onclick = () => {
      currentLayoutKey = key;
      document.querySelectorAll('#layoutControls button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyLayout(); // Rebuild physical grid slots
    };
    layoutControls.appendChild(btn);
  });

  // 2. Generate Theme Buttons
  Object.keys(FRAMES).forEach(key => {
    const btn = document.createElement("button");
    btn.className = "opt-btn" + (key === currentFrameKey ? " active" : "");
    btn.textContent = FRAMES[key].name;
    btn.onclick = () => {
      currentFrameKey = key;
      document.querySelectorAll('#themeControls button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyTheme(); // Change colors
    };
    themeControls.appendChild(btn);
  });

  // 3. Generate Filter Buttons
  Object.keys(FILTERS).forEach(key => {
    const btn = document.createElement("button");
    btn.className = "opt-btn" + (key === currentFilterKey ? " active" : "");
    btn.textContent = FILTERS[key].name;
    btn.onclick = () => {
      currentFilterKey = key;
      document.querySelectorAll('#filterControls button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyLiveFilter(); // Apply CSS filters
    };
    filterControls.appendChild(btn);
  });

  // Setup initial view
  applyAdminText();
  applyTheme();
  applyLayout();
  applyLiveFilter();
  startCamera();
}

/* ================= ADMIN LOGIC ================= */
openAdminBtn.onclick = () => {
  adminPin.value = '';
  adminLoginView.classList.remove('hidden');
  adminSettingsView.classList.add('hidden');
  adminModal.classList.add('active');
};

loginBtn.onclick = () => {
  if (adminPin.value === ADMIN_PIN) {
    adminLoginView.classList.add('hidden');
    adminSettingsView.classList.remove('hidden');
    inputTitle.value = EVENT_NAME;
    inputSubtitle.value = EVENT_DATE;
  } else {
    alert("Incorrect PIN");
  }
};

saveAdminBtn.onclick = () => {
  EVENT_NAME = inputTitle.value.trim() || "My Photobooth";
  EVENT_DATE = inputSubtitle.value.trim() || "Capture the moment";
  applyAdminText();
  adminModal.classList.remove('active');
};

function applyAdminText() {
  overlayTitle.textContent = EVENT_NAME;
  overlaySubtitle.textContent = EVENT_DATE;
}

/* ================= LIVE PREVIEWS & GRID ================= */
function applyTheme() {
  const frame = FRAMES[currentFrameKey];
  document.documentElement.style.setProperty('--theme-color', frame.bgFill);
  overlayTitle.style.color = frame.textCol;
  overlaySubtitle.style.color = frame.textCol === 'black' ? '#555' : '#ccc';
}

function applyLiveFilter() {
  const f = FILTERS[currentFilterKey];
  video.style.filter = f.css;
  let bg = `linear-gradient(${f.overlay}, ${f.overlay})`;
  if (f.vignette) bg += `, radial-gradient(circle, transparent 40%, rgba(0,0,0,0.65) 120%)`;
  videoOverlay.style.background = bg;
}

function applyLayout() {
  const layout = LAYOUTS[currentLayoutKey];
  liveGrid.innerHTML = ''; // Wipe existing slots
  
  // Set the CSS Grid dimensions
  liveGrid.style.gridTemplateColumns = `repeat(${layout.cols}, 1fr)`;
  liveGrid.style.gridTemplateRows = `repeat(${layout.rows}, 1fr)`;

  // Create empty slots
  for (let i = 0; i < layout.count; i++) {
    const slot = document.createElement('div');
    slot.className = 'grid-slot';
    slot.id = `slot-${i}`;
    liveGrid.appendChild(slot);
  }

  // Inject the live video feed and overlay into Slot 0
  const firstSlot = document.getElementById('slot-0');
  if (firstSlot) {
    video.classList.remove('hidden');
    videoOverlay.classList.remove('hidden');
    firstSlot.appendChild(video);
    firstSlot.appendChild(videoOverlay);
  }
}

/* ================= CAMERA CONTROL ================= */
async function startCamera() {
  if (stream) stream.getTracks().forEach(t => t.stop());
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: facingMode, width: { ideal: 1080 }, height: { ideal: 1440 } }
    });
    video.srcObject = stream;
    video.style.transform = facingMode === "user" ? "scaleX(-1)" : "scaleX(1)";
  } catch (err) {
    alert("Camera permission is required to use the photobooth.");
  }
}

flipBtn.onclick = () => {
  facingMode = facingMode === "environment" ? "user" : "environment";
  startCamera();
};

flashBtn.onclick = async () => {
  flashEnabled = !flashEnabled;
  flashBtn.classList.toggle("active", flashEnabled);
  
  if (stream) {
    const track = stream.getVideoTracks()[0];
    if (typeof track.getCapabilities === "function" && track.getCapabilities().torch) {
      try { await track.applyConstraints({ advanced: [{ torch: flashEnabled }] }); } catch(e){}
    }
  }
};

/* ================= SEQUENCE CAPTURE LOGIC ================= */
const sleep = ms => new Promise(r => setTimeout(r, ms));

async function doCountdown(seconds) {
  countdownOverlay.classList.remove("hidden");
  for (let i = seconds; i > 0; i--) {
    countdownOverlay.textContent = i;
    countdownOverlay.style.transform = "translate(-50%, -50%) scale(1.4)";
    setTimeout(() => { countdownOverlay.style.transform = "translate(-50%, -50%) scale(1)"; }, 150);
    await sleep(1000);
  }
  countdownOverlay.classList.add("hidden");
}

function triggerScreenFlash() {
  flashOverlay.style.transition = "none";
  flashOverlay.style.opacity = "1";
  setTimeout(() => {
    flashOverlay.style.transition = "opacity 0.4s ease-out";
    flashOverlay.style.opacity = "0";
  }, 100);
}

shutterBtn.onclick = async () => {
  const layout = LAYOUTS[currentLayoutKey];
  capturedPhotos = [];
  
  // Disable UI during sequence
  shutterBtn.disabled = true;
  mainControls.style.opacity = "0.4";
  mainControls.style.pointerEvents = "none";
  
  if (layout.count > 1) {
    sequenceIndicator.classList.remove("hidden");
  }

  for (let i = 0; i < layout.count; i++) {
    if (layout.count > 1) {
      sequenceIndicator.textContent = `Shot ${i + 1} of ${layout.count}`;
    }
    
    await doCountdown(3);
    
    if (flashEnabled) {
      triggerScreenFlash();
      await sleep(150);
    }

    // Capture the frame quietly in the background
    const frameCanvas = grabSingleFrame();
    capturedPhotos.push(frameCanvas);

    // 1. Create a physical image element from the frame
    const img = document.createElement("img");
    img.src = frameCanvas.toDataURL("image/jpeg", 0.85);

    // 2. Remove the live video from the current slot, replace with the image
    const currentSlot = document.getElementById(`slot-${i}`);
    currentSlot.removeChild(video);
    currentSlot.removeChild(videoOverlay);
    currentSlot.appendChild(img);

    // 3. Jump the live video forward to the NEXT slot (if there is one)
    if (i + 1 < layout.count) {
      const nextSlot = document.getElementById(`slot-${i + 1}`);
      nextSlot.appendChild(video);
      nextSlot.appendChild(videoOverlay);
      await sleep(500); // Quick breather before next countdown
    }
  }

  sequenceIndicator.classList.add("hidden");
  
  // Build final high-res canvas invisible in the background for uploading
  buildComposition(capturedPhotos, layout);
  
  // Swap Controls to Upload mode
  mainControls.classList.add("hidden");
  uploadControls.classList.remove("hidden");
};

function grabSingleFrame() {
  const offCanvas = document.createElement("canvas");
  offCanvas.width = 720;
  offCanvas.height = 960;
  const octx = offCanvas.getContext("2d");

  // Mirror logic for front camera
  if (facingMode === "user") {
    octx.translate(offCanvas.width, 0);
    octx.scale(-1, 1);
  }
  
  // Apply CSS Color grades to the permanent photo
  octx.filter = FILTERS[currentFilterKey].css;
  octx.drawImage(video, 0, 0, offCanvas.width, offCanvas.height);
  octx.setTransform(1, 0, 0, 1, 0, 0);
  octx.filter = "none";

  // Apply Tints and Vignettes to the permanent photo
  const filter = FILTERS[currentFilterKey];
  if (filter.overlay !== 'transparent') {
    octx.fillStyle = filter.overlay;
    octx.fillRect(0, 0, offCanvas.width, offCanvas.height);
  }
  if (filter.vignette) {
    const v = octx.createRadialGradient(offCanvas.width/2, offCanvas.height/2, offCanvas.width/4, offCanvas.width/2, offCanvas.height/2, offCanvas.width);
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(1, "rgba(0,0,0,0.65)");
    octx.fillStyle = v;
    octx.fillRect(0, 0, offCanvas.width, offCanvas.height);
  }
  
  return offCanvas;
}

/* ================= BUILD FINAL HIGH-RES UPLOAD ================= */
// This creates the large, stitched photo in a hidden canvas
function buildComposition(photos, layout) {
  const frame = FRAMES[currentFrameKey];
  const pW = 720;
  const pH = 960;
  const gap = 30;
  const outerPad = 40;
  const bottomSpace = 280; 

  canvas.width = (outerPad * 2) + (pW * layout.cols) + (gap * (layout.cols - 1));
  canvas.height = outerPad + bottomSpace + (pH * layout.rows) + (gap * (layout.rows - 1));

  ctx.fillStyle = frame.bgFill;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  photos.forEach((photoCanvas, i) => {
    const col = i % layout.cols;
    const row = Math.floor(i / layout.cols);
    const x = outerPad + col * (pW + gap);
    const y = outerPad + row * (pH + gap);
    
    ctx.drawImage(photoCanvas, x, y, pW, pH);
    
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.lineWidth = 4;
    ctx.strokeRect(x, y, pW, pH);
  });

  ctx.textAlign = "center";
  ctx.fillStyle = frame.textCol;
  const textY = canvas.height - (bottomSpace * 0.45);
  
  ctx.font = `900 ${canvas.width * 0.05}px sans-serif`;
  ctx.fillText(EVENT_NAME.toUpperCase(), canvas.width / 2, textY);
  
  ctx.font = `600 ${canvas.width * 0.025}px sans-serif`;
  ctx.fillStyle = frame.textCol === 'black' ? '#555555' : '#cccccc';
  ctx.fillText(EVENT_DATE, canvas.width / 2, textY + (canvas.width * 0.04));
}

/* ================= UPLOAD & RETAKE ================= */
retakeBtn.onclick = () => {
  uploadControls.classList.add("hidden");
  document.getElementById("statusMessage").classList.add("hidden");
  
  // Wipe the live UI and rebuild the layout from scratch
  applyLayout();
  mainControls.classList.remove("hidden");
  
  shutterBtn.disabled = false;
  mainControls.style.opacity = "1";
  mainControls.style.pointerEvents = "auto";
};

uploadBtn.onclick = async () => {
  uploadBtn.disabled = true;
  retakeBtn.disabled = true;
  const statusMessage = document.getElementById("statusMessage");
  statusMessage.className = "loading";
  statusMessage.textContent = "Uploading to gallery‚Ä¶";
  statusMessage.classList.remove("hidden");

  try {
    const blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.80));
    const base64 = await new Promise((res, rej) => {
      const reader = new FileReader();
      reader.onload = () => res(reader.result.split(",")[1]);
      reader.onerror = rej;
      reader.readAsDataURL(blob);
    });

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 35000); 

    const res = await fetch(UPLOAD_URL, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      signal: controller.signal,
      body: JSON.stringify({
        file: base64,
        filename: `snapback_${Date.now()}.jpg`,
        mimeType: "image/jpeg"
      })
    });
    
    clearTimeout(timeout);
    if (!res.ok) throw new Error("Server error");
    await res.text();

    statusMessage.className = "success";
    statusMessage.textContent = "‚úÖ Upload complete! Thank you üíñ";
    uploadControls.classList.add("hidden");

    setTimeout(() => {
      retakeBtn.onclick(); 
      uploadBtn.disabled = false;
      retakeBtn.disabled = false;
    }, 2500);

  } catch (err) {
    statusMessage.className = "error";
    statusMessage.textContent = "‚ùå Upload failed. Please try again.";
    uploadBtn.disabled = false;
    retakeBtn.disabled = false;
  }
};

/* Start up */
initUI();
</script>

</body>
</html>
