<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>SNAPBACK Lite</title>

<style>
:root {
  --bg: #f6efe9;
  --accent: #d87c6a;
  --dark: #2f2f2f;
}

* {
  box-sizing: border-box;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--dark);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

header {
  text-align: center;
  margin-bottom: 6px;
}

h1 {
  margin: 0;
  letter-spacing: 2px;
}

.tagline {
  font-size: 12px;
  opacity: 0.7;
}

/* ===== VIEWPORT ===== */
.view-container {
  position: relative;
  width: 100%;
  max-width: 420px;
  border-radius: 12px;
  overflow: hidden;
  background: black;
  margin: 10px 0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

video, canvas {
  width: 100%;
  display: block;
}

#videoOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none; /* Allows clicking through to video if needed */
  transition: background 0.3s ease;
}

/* ===== CONTROLS ===== */
.controls {
  display: flex;
  gap: 8px;
  margin: 6px 0;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
  max-width: 420px;
}

.filter-controls {
  flex-wrap: nowrap;
  overflow-x: auto;
  padding: 0 15px 10px 15px;
  justify-content: flex-start;
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}
.filter-controls::-webkit-scrollbar {
  display: none; /* Chrome, Safari and Opera */
}

button {
  padding: 10px 16px;
  border-radius: 18px;
  border: none;
  background: #fff;
  font-size: 13px;
  cursor: pointer;
  white-space: nowrap;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  transition: all 0.2s ease;
}

button.active {
  background: var(--dark);
  color: white;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.primary {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  background: var(--accent);
  color: white;
  font-size: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;
}

.hidden {
  display: none !important;
}

/* ===== STATUS MESSAGE ===== */
#statusMessage {
  margin-top: 10px;
  padding: 10px 14px;
  border-radius: 14px;
  font-size: 14px;
  text-align: center;
  max-width: 280px;
}

#statusMessage.loading {
  background: #fff3cd;
  color: #856404;
}

#statusMessage.success {
  background: #d4edda;
  color: #155724;
}

#statusMessage.error {
  background: #f8d7da;
  color: #721c24;
}
</style>
</head>

<body>

<header>
  <h1>SNAPBACK</h1>
  <div class="tagline">Old-school vibes. New memories.</div>
</header>

<div class="controls">
  <button id="flipBtn">üîÑ Flip</button>
  <button id="photoBtn" class="active">üì∏ Photo</button>
  <button id="videoBtn">üé• Video</button>
</div>

<div class="view-container">
  <video id="video" autoplay playsinline></video>
  <div id="videoOverlay"></div>
  <canvas id="canvas" class="hidden"></canvas>
</div>

<!-- Dynamic Filter Buttons go here -->
<div class="controls filter-controls" id="filterControls"></div>

<button id="shutter" class="primary">‚óè</button>

<div class="controls hidden" id="uploadControls">
  <button id="uploadBtn">Upload</button>
</div>

<div id="statusMessage" class="hidden"></div>

<script>
/* ================= CONFIG ================= */
const UPLOAD_URL =
"https://script.google.com/macros/s/AKfycbxX9wMOWPLZrimEpvdojQsOh6ESW8kgBw3BK_qYX6VJC8s05tKgYS7BqrnULgrFS5zB/exec";

const FILTERS = {
  none: { name: "None", css: "none", overlay: "transparent", vignette: false },
  warm: { name: "Warm", css: "sepia(0.3) saturate(1.4) contrast(1.1)", overlay: "rgba(255, 140, 0, 0.05)", vignette: true },
  cool: { name: "Cool", css: "saturate(0.8)", overlay: "rgba(0, 100, 255, 0.1)", vignette: false },
  vintage: { name: "Vintage", css: "sepia(0.6) contrast(1.2) brightness(0.9) saturate(1.2)", overlay: "transparent", vignette: true },
  bw: { name: "B&W", css: "grayscale(1) contrast(1.2)", overlay: "transparent", vignette: true },
  soft: { name: "Soft", css: "blur(1px) brightness(1.1) contrast(0.9)", overlay: "rgba(255, 255, 255, 0.1)", vignette: false }
};

/* ================= ELEMENTS ================= */
const video = document.getElementById("video");
const videoOverlay = document.getElementById("videoOverlay");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const flipBtn = document.getElementById("flipBtn");
const photoBtn = document.getElementById("photoBtn");
const videoBtn = document.getElementById("videoBtn");
const shutter = document.getElementById("shutter");
const uploadControls = document.getElementById("uploadControls");
const uploadBtn = document.getElementById("uploadBtn");
const statusMessage = document.getElementById("statusMessage");
const filterControls = document.getElementById("filterControls");

/* ================= STATE ================= */
let stream = null;
let recorder = null;
let chunks = [];
let recordedBlob = null;
let mode = "photo";
let facingMode = "environment";
let currentFilter = "none";

/* ================= UI INIT ================= */
// Generate filter buttons dynamically
Object.keys(FILTERS).forEach(key => {
  const btn = document.createElement("button");
  btn.textContent = FILTERS[key].name;
  btn.onclick = () => {
    currentFilter = key;
    updatePreview();
    // Update active UI state
    document.querySelectorAll('#filterControls button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  };
  filterControls.appendChild(btn);
});
filterControls.querySelector('button').classList.add('active'); // Set first active

/* ================= CAMERA ================= */
async function startCamera(audio = false) {
  if (stream) stream.getTracks().forEach(t => t.stop());

  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: facingMode },
      audio
    });
    video.srcObject = stream;
    
    // Mirror the video if using the front camera
    if (facingMode === "user") {
      video.style.transform = "scaleX(-1)";
    } else {
      video.style.transform = "scaleX(1)";
    }

    statusMessage.classList.add("hidden");
    updatePreview(); // Apply default filter on load
  } catch (err) {
    statusMessage.className = "error";
    statusMessage.textContent = "üì∑ Camera permission is required.";
    statusMessage.classList.remove("hidden");
  }
}

startCamera(false);

/* ================= MODE & FLIP ================= */
flipBtn.onclick = () => {
  facingMode = facingMode === "environment" ? "user" : "environment";
  startCamera(mode === "video");
};

photoBtn.onclick = () => {
  mode = "photo";
  photoBtn.classList.add("active");
  videoBtn.classList.remove("active");
  resetView();
  startCamera(false);
};

videoBtn.onclick = () => {
  mode = "video";
  videoBtn.classList.add("active");
  photoBtn.classList.remove("active");
  resetView();
  startCamera(true);
};

/* ================= REAL-TIME FILTERS ================= */
function updatePreview() {
  const f = FILTERS[currentFilter];
  
  // Apply CSS color corrections
  video.style.filter = f.css;
  
  // Apply overlay (tints and vignettes)
  let bg = `linear-gradient(${f.overlay}, ${f.overlay})`; // Solid tint
  if (f.vignette) {
    bg += `, radial-gradient(circle, transparent 40%, rgba(0,0,0,0.65) 120%)`;
  }
  videoOverlay.style.background = bg;
}

/* ================= SHUTTER ================= */
shutter.onclick = () => {
  if (mode === "photo") takePhoto();
  else recordVideo();
};

/* ================= PHOTO ================= */
function takePhoto() {
  canvas.width = video.videoWidth || 640;
  canvas.height = video.videoHeight || 480;

  const f = FILTERS[currentFilter];

  // 1. Mirror Context if front camera so saved image is correct
  if (facingMode === "user") {
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
  }

  // 2. Apply base CSS filters to Canvas
  ctx.filter = f.css;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  
  // 3. Reset transform & filter so overlays/text apply normally
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.filter = "none";

  // 4. Apply Tints & Vignette on top of the image
  if (f.overlay !== 'transparent') {
    ctx.fillStyle = f.overlay;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  if (f.vignette) {
    const v = ctx.createRadialGradient(
      canvas.width/2, canvas.height/2, canvas.width/4,
      canvas.width/2, canvas.height/2, canvas.width
    );
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(1, "rgba(0,0,0,0.65)");
    ctx.fillStyle = v;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // 5. Draw Date stamp
  drawDate();

  // Swap UI
  video.classList.add("hidden");
  videoOverlay.classList.add("hidden");
  canvas.classList.remove("hidden");
  uploadControls.classList.remove("hidden");
}

function drawDate() {
  ctx.font = "bold 18px monospace";
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.shadowColor = "rgba(0,0,0,0.5)";
  ctx.shadowBlur = 4;
  ctx.fillText(
    new Date().toLocaleDateString(),
    canvas.width - 130,
    canvas.height - 25
  );
  ctx.shadowBlur = 0; // reset
}

/* ================= VIDEO ================= */
function recordVideo() {
  chunks = [];
  recorder = new MediaRecorder(stream);
  recorder.start();
  
  shutter.style.opacity = '0.5';

  setTimeout(() => {
    if (recorder.state === "recording") recorder.stop();
    shutter.style.opacity = '1';
  }, 6000);

  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => {
    recordedBlob = new Blob(chunks, { type: "video/mp4" });
    uploadControls.classList.remove("hidden");
  };
}

/* ================= UPLOAD ================= */
uploadBtn.onclick = async () => {
  uploadBtn.disabled = true;
  statusMessage.className = "loading";
  statusMessage.textContent = "Uploading‚Ä¶";
  statusMessage.classList.remove("hidden");

  try {
    let blob, mime, ext;

    if (mode === "photo") {
      blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.85));
      mime = "image/jpeg";
      ext = "jpg";
    } else {
      if (!recordedBlob) throw new Error("No video recorded");
      blob = recordedBlob;
      mime = "video/mp4";
      ext = "mp4";
    }

    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000); 

    const res = await fetch(UPLOAD_URL, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      signal: controller.signal,
      body: JSON.stringify({
        file: base64,
        filename: `snapback_${Date.now()}.${ext}`,
        mimeType: mime
      })
    });

    clearTimeout(timeout);

    if (!res.ok) throw new Error("Server error");

    await res.text();

    statusMessage.className = "success";
    statusMessage.textContent = "‚úÖ Upload complete! Thank you üíñ";
    uploadControls.classList.add("hidden");

    setTimeout(() => {
      resetView();
      startCamera(mode === "video");
    }, 2000);

  } catch (err) {
    console.error(err);
    statusMessage.className = "error";
    statusMessage.textContent =
      err.name === "AbortError"
        ? "‚ùå Upload timed out. Please try again."
        : "‚ùå Upload failed. Please try again.";
    uploadBtn.disabled = false;
  }
};

/* ================= RESET ================= */
function resetView() {
  uploadControls.classList.add("hidden");
  statusMessage.classList.add("hidden");
  canvas.classList.add("hidden");
  video.classList.remove("hidden");
  videoOverlay.classList.remove("hidden");
  uploadBtn.disabled = false;
}
</script>

</body>
</html>
