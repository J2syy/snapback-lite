<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>SNAPBACK Event Edition</title>

<style>
:root {
  --bg: #f6efe9;
  --accent: #d87c6a;
  --dark: #2f2f2f;
}

* {
  box-sizing: border-box;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--dark);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

header {
  text-align: center;
  margin-bottom: 6px;
}

h1 {
  margin: 0;
  letter-spacing: 2px;
}

.tagline {
  font-size: 12px;
  opacity: 0.7;
}

/* ===== VIEWPORT ===== */
.view-container {
  position: relative;
  width: 100%;
  max-width: 420px;
  /* Maintain a standard 4:3 aspect ratio container */
  aspect-ratio: 3/4; 
  border-radius: 12px;
  overflow: hidden;
  background: black;
  margin: 10px 0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

video, canvas {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

#videoOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  transition: background 0.3s ease;
  z-index: 2;
}

/* ===== EVENT TEMPLATE OVERLAY ===== */
#templateOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 5;
  
  /* Creates the Polaroid Frame Look */
  border: 15px solid white;
  border-bottom-width: 80px; 
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  padding-bottom: 20px;
}

.event-title {
  color: black;
  font-weight: 800;
  font-size: 20px;
  letter-spacing: 1px;
  margin: 0
  text-transform: uppercase;
}

.event-subtitle {
  color: #555;
  font-size: 12px;
  margin-top: 2px;
  letter-spacing: 2px;
}

#flashOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: white;
  opacity: 0;
  pointer-events: none;
  z-index: 10;
}

/* ===== CONTROLS ===== */
.controls {
  display: flex;
  gap: 8px;
  margin: 6px 0;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
  max-width: 420px;
}

.filter-controls {
  flex-wrap: nowrap;
  overflow-x: auto;
  padding: 0 15px 10px 15px;
  justify-content: flex-start;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.filter-controls::-webkit-scrollbar {
  display: none;
}

button {
  padding: 10px 16px;
  border-radius: 18px;
  border: none;
  background: #fff;
  font-size: 13px;
  cursor: pointer;
  white-space: nowrap;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
  transition: all 0.2s ease;
}

button.active {
  background: var(--dark);
  color: white;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.primary {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  background: var(--accent);
  color: white;
  font-size: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;
}

.hidden {
  display: none !important;
}

/* ===== STATUS MESSAGE ===== */
#statusMessage {
  margin-top: 10px;
  padding: 10px 14px;
  border-radius: 14px;
  font-size: 14px;
  text-align: center;
  max-width: 280px;
}

#statusMessage.loading {
  background: #fff3cd;
  color: #856404;
}

#statusMessage.success {
  background: #d4edda;
  color: #155724;
}

#statusMessage.error {
  background: #f8d7da;
  color: #721c24;
}
</style>
</head>

<body>

<header>
  <h1>SNAPBACK</h1>
  <div class="tagline">Old-school vibes. New memories.</div>
</header>

<div class="controls">
  <button id="flashBtn">‚ö° Flash: OFF</button>
  <button id="flipBtn">üîÑ Flip</button>
  <button id="photoBtn" class="active">üì∏ Photo</button>
  <button id="videoBtn">üé• Video</button>
</div>

<div class="view-container">
  <video id="video" autoplay playsinline></video>
  
  <!-- Live Filter Tint -->
  <div id="videoOverlay"></div>
  
  <!-- Visual Event Frame Overlay -->
  <div id="templateOverlay">
    <div class="event-title" id="overlayTitle"></div>
    <div class="event-subtitle" id="overlaySubtitle"></div>
  </div>

  <div id="flashOverlay"></div>
  <canvas id="canvas" class="hidden"></canvas>
</div>

<!-- Dynamic Filter Buttons go here -->
<div class="controls filter-controls" id="filterControls"></div>

<button id="shutter" class="primary">‚óè</button>

<div class="controls hidden" id="uploadControls">
  <button id="uploadBtn">Upload to Gallery</button>
  <button id="retakeBtn">Retake</button>
</div>

<div id="statusMessage" class="hidden"></div>

<script>
/* ================= EVENT CONFIG ================= */
// Change these values for your specific event!
const EVENT_NAME = "Eighteen by Elijah Mae";
const EVENT_DATE = "La Union ‚Ä¢ 2026";

const UPLOAD_URL = "https://script.google.com/macros/s/AKfycbxX9wMOWPLZrimEpvdojQsOh6ESW8kgBw3BK_qYX6VJC8s05tKgYS7BqrnULgrFS5zB/exec";

/* Set visual text on the live template */
document.getElementById('overlayTitle').textContent = EVENT_NAME;
document.getElementById('overlaySubtitle').textContent = EVENT_DATE;

/* ================= FILTERS ================= */
const FILTERS = {
  none: { name: "None", css: "none", overlay: "transparent", vignette: false },
  warm: { name: "Warm", css: "sepia(0.3) saturate(1.4) contrast(1.1)", overlay: "rgba(255, 140, 0, 0.05)", vignette: true },
  cool: { name: "Cool", css: "saturate(0.8)", overlay: "rgba(0, 100, 255, 0.1)", vignette: false },
  vintage: { name: "Vintage", css: "sepia(0.6) contrast(1.2) brightness(0.9) saturate(1.2)", overlay: "transparent", vignette: true },
  bw: { name: "B&W", css: "grayscale(1) contrast(1.2)", overlay: "transparent", vignette: true },
  soft: { name: "Soft", css: "blur(1px) brightness(1.1) contrast(0.9)", overlay: "rgba(255, 255, 255, 0.1)", vignette: false }
};

/* ================= ELEMENTS ================= */
const video = document.getElementById("video");
const videoOverlay = document.getElementById("videoOverlay");
const templateOverlay = document.getElementById("templateOverlay");
const flashOverlay = document.getElementById("flashOverlay");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const flashBtn = document.getElementById("flashBtn");
const flipBtn = document.getElementById("flipBtn");
const photoBtn = document.getElementById("photoBtn");
const videoBtn = document.getElementById("videoBtn");
const shutter = document.getElementById("shutter");
const uploadControls = document.getElementById("uploadControls");
const uploadBtn = document.getElementById("uploadBtn");
const retakeBtn = document.getElementById("retakeBtn");
const statusMessage = document.getElementById("statusMessage");
const filterControls = document.getElementById("filterControls");

/* ================= STATE ================= */
let stream = null;
let recorder = null;
let chunks = [];
let recordedBlob = null;
let mode = "photo";
let facingMode = "environment";
let currentFilter = "none";
let flashEnabled = false;

/* ================= UI INIT ================= */
Object.keys(FILTERS).forEach(key => {
  const btn = document.createElement("button");
  btn.textContent = FILTERS[key].name;
  btn.onclick = () => {
    currentFilter = key;
    updatePreview();
    document.querySelectorAll('#filterControls button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  };
  filterControls.appendChild(btn);
});
filterControls.querySelector('button').classList.add('active');

/* ================= CAMERA ================= */
async function startCamera(audio = false) {
  if (stream) stream.getTracks().forEach(t => t.stop());

  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: facingMode, width: { ideal: 1080 }, height: { ideal: 1440 } },
      audio
    });
    video.srcObject = stream;
    
    if (facingMode === "user") {
      video.style.transform = "scaleX(-1)";
    } else {
      video.style.transform = "scaleX(1)";
    }

    const track = stream.getVideoTracks()[0];
    if (flashEnabled && typeof track.getCapabilities === "function") {
      const caps = track.getCapabilities();
      if (caps.torch) {
        try { await track.applyConstraints({ advanced: [{ torch: true }] }); }
        catch (e) { console.warn("Could not activate hardware torch", e); }
      }
    }

    statusMessage.classList.add("hidden");
    updatePreview();
  } catch (err) {
    statusMessage.className = "error";
    statusMessage.textContent = "üì∑ Camera permission is required.";
    statusMessage.classList.remove("hidden");
  }
}

startCamera(false);

/* ================= MODE & FLIP ================= */
flashBtn.onclick = async () => {
  flashEnabled = !flashEnabled;
  flashBtn.textContent = flashEnabled ? "‚ö° Flash: ON" : "‚ö° Flash: OFF";
  flashBtn.classList.toggle("active", flashEnabled);

  if (stream) {
    const track = stream.getVideoTracks()[0];
    if (typeof track.getCapabilities === "function") {
      const caps = track.getCapabilities();
      if (caps.torch) {
        try { await track.applyConstraints({ advanced: [{ torch: flashEnabled }] }); } 
        catch (e) {}
      }
    }
  }
};

flipBtn.onclick = () => {
  facingMode = facingMode === "environment" ? "user" : "environment";
  startCamera(mode === "video");
};

photoBtn.onclick = () => {
  mode = "photo";
  photoBtn.classList.add("active");
  videoBtn.classList.remove("active");
  templateOverlay.style.display = "flex"; // Show template for photos
  resetView();
  startCamera(false);
};

videoBtn.onclick = () => {
  mode = "video";
  videoBtn.classList.add("active");
  photoBtn.classList.remove("active");
  templateOverlay.style.display = "none"; // Hide template for video
  resetView();
  startCamera(true);
};

/* ================= REAL-TIME FILTERS ================= */
function updatePreview() {
  const f = FILTERS[currentFilter];
  video.style.filter = f.css;
  let bg = `linear-gradient(${f.overlay}, ${f.overlay})`;
  if (f.vignette) bg += `, radial-gradient(circle, transparent 40%, rgba(0,0,0,0.65) 120%)`;
  videoOverlay.style.background = bg;
}

/* ================= SHUTTER ================= */
shutter.onclick = () => {
  if (mode === "photo") takePhoto();
  else recordVideo();
};

/* ================= PHOTO & BURN WATERMARK ================= */
function takePhoto() {
  if (flashEnabled) {
    flashOverlay.style.transition = "none";
    flashOverlay.style.opacity = "1";
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        setTimeout(() => {
          captureFrame();
          flashOverlay.style.transition = "opacity 0.4s ease-out";
          flashOverlay.style.opacity = "0";
        }, 200); 
      });
    });
  } else {
    captureFrame();
  }
}

function captureFrame() {
  // Use actual video dimensions
  canvas.width = video.videoWidth || 640;
  canvas.height = video.videoHeight || 480;

  const f = FILTERS[currentFilter];

  // 1. Draw Camera Feed
  if (facingMode === "user") {
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
  }
  ctx.filter = f.css;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  
  // Reset context
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.filter = "none";

  // 2. Draw Filter Overlays
  if (f.overlay !== 'transparent') {
    ctx.fillStyle = f.overlay;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  if (f.vignette) {
    const v = ctx.createRadialGradient(
      canvas.width/2, canvas.height/2, canvas.width/4,
      canvas.width/2, canvas.height/2, canvas.width
    );
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(1, "rgba(0,0,0,0.65)");
    ctx.fillStyle = v;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // 3. Draw Vintage Date (Moved up slightly to avoid bottom border)
  drawDate();

  // 4. DRAW THE EVENT TEMPLATE (Polaroid Border)
  // Calculate relative sizes based on actual canvas resolution
  const topSideBorder = canvas.width * 0.04; // ~4% width for sides/top
  const bottomBorder = canvas.height * 0.18; // ~18% height for the bottom text area

  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, topSideBorder); // Top
  ctx.fillRect(0, 0, topSideBorder, canvas.height); // Left
  ctx.fillRect(canvas.width - topSideBorder, 0, topSideBorder, canvas.height); // Right
  ctx.fillRect(0, canvas.height - bottomBorder, canvas.width, bottomBorder); // Bottom

  // 5. DRAW THE EVENT WATERMARK TEXT
  ctx.fillStyle = "black";
  ctx.textAlign = "center";
  
  // Event Name
  ctx.font = `900 ${canvas.width * 0.06}px sans-serif`;
  ctx.fillText(EVENT_NAME.toUpperCase(), canvas.width / 2, canvas.height - (bottomBorder * 0.45));
  
  // Event Date
  ctx.font = `600 ${canvas.width * 0.03}px sans-serif`;
  ctx.fillStyle = "#555555";
  ctx.fillText(EVENT_DATE, canvas.width / 2, canvas.height - (bottomBorder * 0.2));

  // Swap UI
  video.classList.add("hidden");
  videoOverlay.classList.add("hidden");
  templateOverlay.style.display = "none"; // Hide live template, show canvas
  shutter.classList.add("hidden");
  canvas.classList.remove("hidden");
  uploadControls.classList.remove("hidden");
}

function drawDate() {
  ctx.font = "bold 24px monospace";
  ctx.fillStyle = "rgba(255,150,50,0.9)"; // Vintage orange/red date
  ctx.shadowColor = "rgba(0,0,0,0.5)";
  ctx.shadowBlur = 4;
  
  // Adjust position to sit right above the bottom white border
  const bottomBorder = canvas.height * 0.18;
  const rightBorder = canvas.width * 0.04;
  
  ctx.fillText(
    new Date().toLocaleDateString(),
    canvas.width - rightBorder - 160,
    canvas.height - bottomBorder - 20
  );
  ctx.shadowBlur = 0; // reset
}

/* ================= RETAKE ================= */
retakeBtn.onclick = () => {
  resetView();
  startCamera(false);
};

/* ================= VIDEO ================= */
function recordVideo() {
  chunks = [];
  recorder = new MediaRecorder(stream);
  recorder.start();
  
  shutter.style.opacity = '0.5';

  setTimeout(() => {
    if (recorder.state === "recording") recorder.stop();
    shutter.style.opacity = '1';
  }, 6000);

  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => {
    recordedBlob = new Blob(chunks, { type: "video/mp4" });
    shutter.classList.add("hidden");
    uploadControls.classList.remove("hidden");
  };
}

/* ================= UPLOAD ================= */
uploadBtn.onclick = async () => {
  uploadBtn.disabled = true;
  retakeBtn.disabled = true;
  statusMessage.className = "loading";
  statusMessage.textContent = "Uploading to gallery‚Ä¶";
  statusMessage.classList.remove("hidden");

  try {
    let blob, mime, ext;

    if (mode === "photo") {
      blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.85));
      mime = "image/jpeg";
      ext = "jpg";
    } else {
      if (!recordedBlob) throw new Error("No video recorded");
      blob = recordedBlob;
      mime = "video/mp4";
      ext = "mp4";
    }

    const base64 = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000); 

    const res = await fetch(UPLOAD_URL, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" },
      signal: controller.signal,
      body: JSON.stringify({
        file: base64,
        filename: `snapback_${Date.now()}.${ext}`,
        mimeType: mime
      })
    });

    clearTimeout(timeout);

    if (!res.ok) throw new Error("Server error");

    await res.text();

    statusMessage.className = "success";
    statusMessage.textContent = "‚úÖ Upload complete! Thank you üíñ";
    uploadControls.classList.add("hidden");

    setTimeout(() => {
      resetView();
      startCamera(mode === "video");
    }, 2000);

  } catch (err) {
    console.error(err);
    statusMessage.className = "error";
    statusMessage.textContent =
      err.name === "AbortError"
        ? "‚ùå Upload timed out. Please try again."
        : "‚ùå Upload failed. Please try again.";
    uploadBtn.disabled = false;
    retakeBtn.disabled = false;
  }
};

/* ================= RESET ================= */
function resetView() {
  uploadControls.classList.add("hidden");
  statusMessage.classList.add("hidden");
  canvas.classList.add("hidden");
  video.classList.remove("hidden");
  videoOverlay.classList.remove("hidden");
  shutter.classList.remove("hidden");
  
  if(mode === "photo") {
    templateOverlay.style.display = "flex";
  }
  
  uploadBtn.disabled = false;
  retakeBtn.disabled = false;
}
</script>

</body>
</html>
