<script>
const UPLOAD_URL =
"https://script.google.com/macros/s/AKfycbyVToSlr4MJ_j1Um8LwrCzyL0oy7SWuJ4dmsXB1yrRonVQZ39JD1dXUNxj7j9KPL2Xd/exec";

const video = document.getElementById("camera");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let stream = null;
let mediaRecorder = null;
let chunks = [];
let recordedBlob = null;
let mode = "photo";
let filter = "warm";

// ---------- CAMERA ----------
async function startCamera(withAudio = false) {
  try {
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: withAudio
    });
    video.srcObject = stream;
  } catch (e) {
    alert("Please allow camera access and refresh.");
  }
}
startCamera(false);

// ---------- MODE ----------
photoMode.onclick = () => {
  mode = "photo";
  startCamera(false);
};
videoMode.onclick = () => {
  mode = "video";
  startCamera(true);
};

// ---------- SHUTTER ----------
shutter.onclick = () => {
  if (mode === "photo") capturePhoto();
  else recordVideo();
};

// ---------- PHOTO ----------
function capturePhoto() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0);

  applyFilter();
  drawDate();

  video.classList.add("hidden");
  canvas.classList.remove("hidden");
  uploadControls.classList.remove("hidden");
}

// ---------- FILTERS ----------
function applyFilter() {
  if (filter === "warm") {
    ctx.fillStyle = "rgba(255,180,130,0.12)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  if (filter === "grainy") {
    ctx.globalAlpha = 0.15;
    for (let i = 0; i < 4000; i++) {
      ctx.fillStyle = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`;
      ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  if (filter === "soft") {
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // vignette (always)
  const v = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, canvas.width/4,
    canvas.width/2, canvas.height/2, canvas.width/1.1
  );
  v.addColorStop(0,"rgba(0,0,0,0)");
  v.addColorStop(1,"rgba(0,0,0,0.45)");
  ctx.fillStyle = v;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

// ---------- DATE ----------
function drawDate() {
  const date = new Date().toLocaleDateString();
  ctx.font = "16px monospace";
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.fillText(date, canvas.width - 110, canvas.height - 20);
}

// ---------- VIDEO ----------
function recordVideo() {
  chunks = [];
  mediaRecorder = new MediaRecorder(stream);
  mediaRecorder.start();
  setTimeout(() => mediaRecorder.stop(), 10000);

  mediaRecorder.ondataavailable = e => chunks.push(e.data);
  mediaRecorder.onstop = () => {
    recordedBlob = new Blob(chunks, { type: "video/mp4" });
    uploadControls.classList.remove("hidden");
  };
}

// ---------- UPLOAD ----------
uploadBtn.onclick = async () => {
  let blob, mime;

  if (mode === "photo") {
    blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.9));
    mime = "image/jpeg";
  } else {
    blob = recordedBlob;
    mime = "video/mp4";
  }

  const reader = new FileReader();
  reader.onloadend = async () => {
    await fetch(UPLOAD_URL, {
      method: "POST",
      body: JSON.stringify({
        file: reader.result.split(",")[1],
        filename: `snapback_${Date.now()}.${mode === "photo" ? "jpg" : "mp4"}`,
        mimeType: mime
      })
    });

    document.body.innerHTML = success.outerHTML;
    success.classList.remove("hidden");
  };
  reader.readAsDataURL(blob);
};

// ---------- FILTER BUTTONS ----------
const filters = ["warm","grainy","soft","none"];
filters.forEach(f => {
  const b = document.createElement("button");
  b.textContent = f;
  b.onclick = () => filter = f;
  document.querySelector(".controls").appendChild(b);
});
</script>
